




<https://www.bilibili.com/video/BV1Dw411f7Ht/?spm_id_from=333.337.search-card.all.click&vd_source=972491eeb83c0ed4c0015aef1be6c537>
CTF题：
RSA密钥对生成中，假设已知公钥生成的数据： p=473398607161，q=4511491，e=17，n=p*q

计算出私钥中d （知道p,q,e）或 明文（知道密文c，私钥d）
作为flag提交。


![rsa2222](http://cdn.33129999.xyz/mk_img/rsa2222.png)

![image-20240502203810720](http://cdn.33129999.xyz/mk_img/image-20240502203810720.png)




## **求密钥对**
公钥是(E, N)，私钥是(D, N)，密钥对即为(E, D, N)


## **求大质数p q**
知道n
1、自动求n的两个大质数p * q：<http://factordb.com/index.php?query=121>
2、p和q接近时可以用费马分解脚本求
3、其他情况最好用yafu.exe程序求
```
yafu.exe "factor(2056802480868100646375721251575555494408897387375737955882170045672576386016591560879707933101909539325829251496440620798637813)"
```

## **求私钥中d**
知道p,q,e
使用工具RSA tool2，右上角改为10，e改为16进制数，点计算获取私钥d。
<https://blog.csdn.net/MikeCoke/article/details/105920084>
或使用python库计算d。
```
import gmpy2

p=3487583947589437589237958723892346254777
q=8767867843568934765983476584376578389
e=65537
phi=(p-1)*(q-1)
d=gmpy2.invert(e,phi) //d * e mod phi =1 

求逆元 d×e≡1(mod phi)
即d * e mod phi =1 ，这里知道e和phi求d值。
d * e mod (p-1)*(q-1) =1

```

^
## **求明文**
python求明文
```
e = 65537
p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483
q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407
n = p*q
#密文
C = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034

d = 56632047571190660567520341028861194862411428416862507034762587229995138605649836960220619903456392752115943299335385163216233744624623848874235303309636393446736347238627793022725260986466957974753004129210680401432377444984195145009801967391196615524488853620232925992387563270746297909112117451398527453977

#求明文
M = pow(C,d,n)    #快速求幂取模运算，C的d次方除以n的余数
print(M)

如果需要字符
from Crypto.Util.number import *
print(long_to_bytes(M))
```

python求d求明文
```
import gmpy2
from Crypto.Util.number import *


c = 1697082756231533018355466609903675961030374295211204263031780026667052588795305611625683707210166680820951233865942584324589846717600714522505497705362361528079110585472853479523248077801468392339748859890516096600440235933452727568225647198688042235131587906777536321713673234275669247831590452558878092362
p = 6783866621664404311360631748289003038812476986464692488622430519698072975163125149270509957965820087334150369541026254843052738867516880253554001805333277
e = 65537
n = 46020846340532418102817194710335878450358476457249195244193151622522917949988948998630265351964693612040303373146638765099906166133117791549122976975352218280780091854706485256641038894635568327402075341944567359298159559111251370138678909039870364343149992495034584254193534368667477930470692144241043558729
q = n // p
d = gmpy2.invert(e, (p - 1) )
print(long_to_bytes(pow(c, d, p)))  
# 这里用c,d,p
```

^

dp dq求明文：<https://blog.csdn.net/MikeCoke/article/details/105959599>
<https://blog.csdn.net/xiao_han_a/article/details/118516038>