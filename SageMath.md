在线版：<https://sagecell.sagemath.org/>
sage的本地环境较大（接近10G）
离线版安装：<https://mirrors.aliyun.com/sagemath/win/index.html>


教程
<https://tanglee.top/2022/03/27/SageMath%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/>
使用
<https://kangming-ux.github.io/crypto/Use-of-Sagemath-in-CTF-Cryptography.html>
```
主要用于解决：
数论
椭圆曲线
RSA变形等题
```
```
安装后桌面：
SageMath 9.3

SageMath 9.3 Shell 命令窗口
可以安装库，如在里面执行 sage -pip install libnum
用离线版可以安装这些库方便数字和字符转换，用在线版会没有这个库，就不能用转换函数，在线版手动转。

SageMath 9.3 Notebook 运行这个此时会有网页版
```
网页使用即可
![](.topwrite/assets/image_1732633628535.png)


^
# **sage脚本**

## **1、m高位攻击**
已知n,c,e。n不能分解，e很小为3。
已知明文m高位，求明文m低位。得m
```
import libnum
def phase2(high_m, n, c):
    R.<x> = PolynomialRing(Zmod(n), implementation='NTL')
    m = high_m + x
    M = m((m^3 - c).small_roots()[0])
    print(libnum.n2s(int(M)))

n= 16375911057984467860173028499662793813198989070891462046702689271326139635781678292779095962528585009670015786235494254339716198163498114440710970519760731615457538963588012609421435357625310123852269659556877780556282784378911243624799312161395869291700339099744622787092292212808041739935363726641015733082591519285930439717736591210957039387077203590963514630879038078615201950805057733038622070074246926048776699133348654093003217709061073510046710565744672093957004519016895478465918909294337641778357708633353664132944153092793959582685432330892190960961439661225639169934805918097911051922729785720701933534021
e= 3
c= 175676150266403934024028881165956357569100114594293998449367661494592439256350774016927790942005197030835672661768700955232102741828268826317608643103085037913845664530507219457425306700667637263739558920826441431873842792152100711788904901597274447160613809337879563457097769364821425046114008763402341
high_m= 56006392793404656900162277604003911130977996870658599363889243117614813715239971694356275604343488512

phase2(high_m, n, c)
```


## **2、p高位攻击**
已知n,c,e。n不能分解。
已知p高位，求低位。的p和q。再求m。
![](.topwrite/assets/image_1732688825513.png)
```
import libnum
def phase3(high_p, n):
    R.<x> = PolynomialRing(Zmod(n), implementation='NTL')
    p = high_p + x
    x0 = p.small_roots(X=2 ^ 60, beta=0.1)[0] #根据题目，注意 2^60  60需要修改相应的位数，出题是128就是128
    P = int(p(x0))
    Q = n // P
    print(P)
    print(Q) # 这里求出的P、Q
    assert n == P * Q

n=0x558477ce1d081f831cfa159290ee4fd14888422c216a16ad86e2b2d4335e3cb18ed0120a955f970b17b229a8e7d0ae1b6f0c40213ad0e127eba99ae0d8a82397
p4=0x8fbcbb7d1e9f393ee21b537d6e0bd2cf8629e315f4e356c1e000000000000000
e=0xf7278179324b11fd83d08aa6f
c=0x36e1c09ccad45cd63a0f07e704d3811c39d70cdfdad999d2df90255a76c58cf6fe99ac1ab1d5d99a4ce1a2ebdbfbc49ce72df2a0b90766ff84ab0ef62068d46b

phase3(p4, n)
```


3、Franklin-Reiter attack


4、d低位攻击

5、广播攻击

6、Boneh Durfee 攻击


7、维纳变形（三素数pqr）









