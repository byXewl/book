## **寄存器**
是cpu的组成成分，一种存储单元。

#### **通用寄存器：**
EAX,EBX,ECX,EDX,EBP,ESP,EDI,ESI

分类：
数据寄存器：EAX,EBX,ECX,EDX
指针寄存器：EBP,ESP
变址寄存器：EDI,ESI

作用：
EAX：32位累加器，是加法乘法指令的缺省寄存器。函数调用的返回值也放这里。
AX：x86，x64中EAX32位或RAX64位的低16位。
AL：累加寄存器的低8位。类似于存放for循环中的i值。
EBX：基址寄存器，在内存寻址时存放基地址。
ECX：计数器，是重复前缀指令（REP）和LOOP指令的内定计数器。
EDX：数据寄存器，被用来放整数除法产生的余数。
EBP：扩展基址指针寄存器。函数开栈的栈底位置。
ESP：栈指针寄存器，指向栈区域的栈顶的位置，栈是一个存放即将会被用到的数据的地方。
EDI：目的变址寄存器。
ESI：源变址寄存器。
EIP：指令指针寄存器，EIP指向下一条将会被执行的指令。软件加壳用到。它用于存储下一条将要执行的指令的地址。因为EIP是硬件控制的，通常由处理器自动更新，用于指示程序的执行流。
如何修改EIP？[BJDCTF 2020]Easy 动态修改EIP的值为某个函数的地址实现强行执行某个函数。

#### **标志位寄存器：**
一个核心一个，多核多个。
功能：这个寄存器存储标志位的状态，标志cpu核心状态。
CF：进位标志，进位时置1，否则置0。
ZF：零标志位，运算结果为0时ZF置1，否则置0。
SF：符号位，结果为负时置1，否则置0。
OF：溢出标志，溢出时为1，否则置0。

^
## **汇编指令**
1、赋值 ：MOV指令
功能：将源操作数传送给目的操作数
```
MOV 目的操作数 源操作数
mov eax,0x10
```



在x86架构中，通常有两个栈：数据栈和调用栈
函数调用相关：
<https://www.bilibili.com/video/BV17M411T7Wq/?spm_id_from=333.337.search-card.all.click>

^
2、加/减  ：ADD/SUB指令
功能：将目的操作数加上源操作数结果存放在目的操作数中。
```
ADD 目的操作数 源操作数
SUB 目的操作数 源操作数
```

3、乘 ： MUL/IMUL指令
功能：根据源操作数的大小决定。源操作数为字节，则AL乘以源操作数，结果放在AX中。
如果源操作数是双字，AX存低位DX存高位。
```
MUL/IMUL 源操作数
```

4、除 ： DIV/IDIV指令
功能：根据源操作数的大小决定。源操作数为字节，则AX除以源操作数，商放在AL中，余数放在AH中。源操作数是双字，则AX除以源操作数，商放在AX中，余数放在DX中。
```
DIV/IDIV 源操作数
```

5、自增/自减 ： INC/DEC指令
功能：目的操作数++或--
```
INC 目的操作数
DEC 目的操作数
```

6、判断比较：CMP指令
功能：比较两个操作数，根据比较结果修改相关条件的标志位
主要和条件转移指令(j开头的)合用，判断语句。
```
CMP 操作数 操作数
je    
```

7、跳转：j开头指令
![image-20240428150813607](http://cdn.33129999.xyz/mk_img/image-20240428150813607.png)



^
8、其他指令
```
test 与操作
xor 异或操作
```



^
## **函数调用的区别**
函数调用约定：
1.参数入栈的顺序
2.在哪里平衡堆栈
种类：stdcall、cdcel、fastcall、thiscall
![image-20240428192846204](http://cdn.33129999.xyz/mk_img/image-20240428192846204.png)


^
## **段和内存**
1、代码段
.text
![](.topwrite/assets/image_1732348144906.png)
2、数据段
数据段常见指令
```
; 注释

`align 4` 会确保接下来的数据地址是4的倍数，`align 16`（或`align 10h`）会确保地址是16的倍数。

`db` 用于定义一个字节（byte）的数据

`dw` 用于定义一个字（word），即两个字节的数据

`dd` 用于定义一个双字（doubleword），即四个字节的数据

`dq` 用于定义一个四字（quadword），即八个字节的数据

`dt` 用于定义十个字节的数据

`dt` 用于定义十个字节的数据

 `rb`、`rw`、`rd`、`rq`、`rt`、`ro`：
这些指令与`db`、`dw`、`dd`、`dq`、`dt`、`do`类似，但是它们在定义数据的同时，还会在数据后面填充零，直到满足指定的大小。例如，`rb 5` 会分配5个字节的空间，但是只初始化第一个字节，其余的四个字节会被填充为零。
```
![](.topwrite/assets/image_1732348177781.png)
![](.topwrite/assets/image_1732431392925.png)
数组末尾的0看情况是否带上
![](.topwrite/assets/image_1732514362599.png)
`.got` 是 ELF（Executable and Linkable Format）文件格式中的一个段，称为全局偏移表（Global Offset Table）。它位于数据段中，主要用来存放全局变量和函数的地址，以支持位置无关代码（Position-Independent Code, PIC）。在动态链接的程序中，`.got` 段用于存储需要延迟绑定的函数和全局变量的地址。这些地址在程序启动时并不立即解析，而是在程序首次访问这些符号时才进行解析和更新。简而言之，`.got` 段为程序提供了一个查找全局变量和函数实际地址的机制



3、BBS段
![](.topwrite/assets/image_1732348240199.png)
4、堆
![](.topwrite/assets/image_1732348273164.png)
5、栈
![](.topwrite/assets/image_1732348312275.png)






^
## **大端小端存储**
![](.topwrite/assets/image_1732538083406.png)
一般x86都是小端序，但是IDA将之转换为了大端序显示。
ELF文件通常使用小端序存储，IDA会把内存中的数据自动转化为大端序存储
```
例如，`0x776F646168LL` 表示的是一个十六进制的数值，转换为十进制大约是 100000000000000000，这个数值超出了32位 `int` 类型能表示的范围，因此需要使用 `long long int` 类型来存储。
`LL` 是一个后缀，表示这是一个长长整型（long long int）的字面量。
又大小端倒序，IDA伪代码显示的0x776F646168LL
而真实值是 68 61 64 6F 77
```

```
在反编译的伪代码中：
int v18; // [sp+30h][bp-10h]@3
int v19; // [sp+34h][bp-ch]@3
char v20; // [sp+38h][bp-8h]@3
v18='1010';
v19='0#11';
v20='1';
点进去查看汇编是
0101
11#0
1
所以如果v18地址一直往后读是0101 11#0 1


__int64 v4
v4[0] = 0x707541504072684Ci64;
实际 4C 68 72 ... 70
```

