## **架构指令集**

| ABI 名            | 指令集    | 位数    | 常见设备                             |
| ---------------- | ------ | ----- | -------------------------------- |
| `armeabi-v7a`    | ARM    | 32    | 老手机、低端 IoT                       |
| `arm64-v8a`      | ARM    | 64    | **>90 % 现役手机**        包括最新ios和安卓           |
| x86 / x86_64(=amd64 ) | Intel  | 32/64 | 模拟器、极少数平板（华硕 ZenFone）            |
| `riscv64`        | RISC-V | 64    | **AOSP 主干已合入**，芯片刚流片，**尚未大规模商用** |

PS：amd64 == x86_64，只是名字不同，指的都是**64位**的 x86 架构。
在 Linux 发行版里，你会看到：
* Ubuntu/Debian 用 `amd64`
* RedHat/CentOS 用 `x86_64`
但它们的二进制是兼容的，没区别。

## **寄存器**
是cpu的组成成分，一种存储单元。

#### **通用寄存器：**
#### x86
```
EAX,EBX,ECX,EDX,EBP,ESP,EDI,ESI

分类：
数据寄存器：EAX,EBX,ECX,EDX
指针寄存器：EBP,ESP
变址寄存器：EDI,ESI

作用：
EAX：32位累加器，是加法乘法指令的缺省寄存器。函数调用的返回值也放这里。也可以做循环的下标值。
AX：x86，x64中EAX32位或RAX64位的低16位。
AL：累加寄存器的低8位。类似于存放for循环中的i值。
EBX：基址寄存器，在内存寻址时存放基地址。
ECX：计数器，是重复前缀指令（REP）和LOOP指令的内定计数器。
EDX：数据寄存器，被用来放整数除法产生的余数。
EBP：扩展基址指针寄存器。函数开栈的栈底位置的低地址。EBP可以指向堆heap（64 位下 RBP ，arm R7寄存器）

ESP：栈指针寄存器，指向栈区域的栈顶的位置，
存放即将会被用到的数据的地方，也就是上一个push数据存储的低地址！
动态调试看关键值。

EDI：目的变址寄存器。
ESI：源变址寄存器。
EIP：指令指针寄存器，EIP指向下一条将会被执行的指令。软件加壳用到。
它用于存储下一条将要执行的指令的地址。
因为EIP是硬件控制的，通常由处理器自动更新，用于指示程序的执行流。

如何修改EIP？[BJDCTF 2020]Easy 双击动态修改EIP的值为某个函数的地址实现强行执行某个函数。
```
^
#### x86_64位寄存器对应关系
| 32位寄存器 | 64位寄存器      | 说明                                     |
| :----- | :---------- | :------------------------------------- |
| EAX    | **RAX**     | 累加器，函数返回值，乘法/除法默认寄存器                   |
| EBX    | **RBX**     | 基址寄存器， callee-saved（被调用者保存）            |
| ECX    | **RCX**     | 计数器，REP前缀/LOOP指令默认计数器，第4个函数参数（Windows） |
| EDX    | **RDX**     | 数据寄存器，除法余数，第3个函数参数（Windows）            |
| ESP    | **RSP**     | 栈指针，指向栈顶                               |
| EBP    | **RBP**     | 基址指针，栈帧基址，callee-saved                 |
| ESI    | **RSI**     | 源变址寄存器，第2个函数参数（Windows）                |
| EDI    | **RDI**     | 目的变址寄存器，第1个函数参数（Windows）               |
| —      | **R8\~R15** | 新增的8个通用寄存器，用于函数参数或临时变量                 |





^
#### arm
| 寄存器名称 | 功能介绍 |
| --- | --- |
| `R0-R12` | 通用寄存器，用于存储临时数据。在函数调用时，`R0-R3`用于存储前四个参数，其余的参数通过堆栈传递。返回值也通过`R0`和`R1`传递。 |
| `R13 (SP)` | 堆栈指针寄存器，指向当前堆栈的顶部。 |
| `R14 (LR)` | 链接寄存器，存储子程序的返回地址。 |
| `R15 (PC)` | 程序计数器，指向下一条要执行的指令。 |
| `CPSR` | 当前程序状态寄存器，保存程序的状态信息，如算术运算的结果标志、中断禁止标志等。 |
| `FPSCR` | 浮点状态和控制寄存器，如果你在调试的代码中涉及到浮点运算，那么这个寄存器会比较重要。 |
|PC | 指令指针寄存器，同eip指向下一条将会被执行的指令。|
#### **标志位寄存器：**
一个核心一个，多核多个。
功能：这个寄存器存储标志位的状态，标志cpu核心状态。
CF：进位标志，进位时置1，否则置0。
ZF：零标志位，运算结果为0时ZF置1，否则置0。
SF：符号位，结果为负时置1，否则置0。
OF：溢出标志，溢出时为1，否则置0。

^
## **汇编指令**
1、赋值 ：MOV指令
功能：将源操作数传送给目的操作数


Intel 语法（Windows/IDA/大多数教材）
```
MOV 目的操作数 源操作数
mov eax,0x10

把地址 0x00401000 处的 1 字节置 0xFF
mov byte ptr [0x00401000], 0FFh
```

^
AT&T 语法（Linux `gas` 默认）
```
movl src, dst ; 把 src 的值 → dst
助记：“源在前，目标在后”
并且寄存器必须加 %，立即数加 $。
```





^
2、加/减  ：ADD/SUB指令
功能：将目的操作数加上源操作数结果存放在目的操作数中。
```
ADD 目的操作数 源操作数
SUB 目的操作数 源操作数
```

3、乘 ： MUL/IMUL指令
功能：根据源操作数的大小决定。源操作数为字节，则AL乘以源操作数，结果放在AX中。
如果源操作数是双字，AX存低位DX存高位。
```
MUL/IMUL 源操作数
```

4、除 ： DIV/IDIV指令
功能：根据源操作数的大小决定。源操作数为字节，则AX除以源操作数，商放在AL中，余数放在AH中。源操作数是双字，则AX除以源操作数，商放在AX中，余数放在DX中。
```
DIV/IDIV 源操作数
```

5、自增/自减 ： INC/DEC指令
功能：目的操作数++或--
```
INC 目的操作数
DEC 目的操作数
```

6、判断比较：CMP指令
功能：比较两个操作数，根据比较结果修改相关条件的标志位
主要和条件转移指令(j开头的)合用，判断语句。
```
CMP 操作数 操作数
je    
```

7、跳转：j开头指令
![image-20240428150813607](http://cdn.33129999.xyz/mk_img/image-20240428150813607.png)



^
8、其他指令
```
lea：把源操作数（必须是一个内存寻址表达式）计算出的“地址偏移量”直接送进目标寄存器，
而不会去访问该地址里存储的实际数据。


test 与操作
xor 异或操作
```





^
