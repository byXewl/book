可执行文件：
PE(win exe)和ELF(linux/安卓)
两者结构类似。
## **文件结构**
1、PE文件格式把可执行文件分成了若干个section节，不同的资源存放在不同的section节中：
.text 编译器产生存放二进制机器代码反汇编调试的主要对象
.data 初始化的数据块，宏定义全局变量静态变量等
.idata可执行文件所使用的动态链接库 外来函数 文件的信息
.rsrc 存放程序资源文件 图标 菜单信息
.rdata资源数据段，程序用到什么资源数据都在这里，资源包括你自己封包的，也包括开发工具自动封包的


^
2、ELF文件的主要组成部分包括：
* ELF Header：文件头，描述文件的基本信息
* Program Header Table：程序头表，描述进程映像的布局
* Section Header Table：节区头表，描述文件的各个节区

| 节区名      | 描述                       |
| -------- | ------------------------ |
| .text    | 代码段，存放程序的指令 （F5伪代码，改指令等） |
| .data    | 数据段，存放已初始化的全局变量和静态变量     |
| .rodata  | 只读数据段，存放只读数据             |
| .bss     | 未初始化数据段，存放未初始化的全局变量和静态变量 |
| .symtab  | 符号表，存放符号信息               |
| .strtab  | 字符串表，存放字符串数据             |
| .dynsym  | 动态符号表，存放动态链接需要的符号信息      |
| .dynamic | 动态链接信息，存放动态链接器需要的信息      |


^
## **PE文件的动态链接库**
需要从动态链接库DLL中导入什么函数
由PE文件中的INT，IAT表决定。
INT导入表，存储函数的名称。PE文件加载前用来保存我要导入的函数名/序号“的只读目录。
IAT导入地址表，存储函数的地址。PE文件加载后被填入真正的DLL函数地址，供CALL直接取址。
程序没有运行时，INT和IAT内容一样。

**用途和使用方法**：
* **动态链接**：导入表和IAT使得PE文件可以动态链接到DLL，这意味着程序可以在运行时才确定它所依赖的DLL的确切位置和内存地址。
* **程序执行**：当一个PE文件被加载到内存中时，操作系统会解析导入表中的DLL名称和函数名称，然后在系统内搜索相应的DLL，并将IAT中的地址更新为DLL中函数的实际内存地址。
* **调试和分析**：开发者和逆向工程师可以查看导入表来了解一个程序依赖哪些DLL以及它需要哪些函数。

**可能的利用**：
* **恶意软件分析**：安全研究人员和恶意软件分析师会检查导入表来识别程序可能的恶意行为，例如尝试导入可疑的DLL或函数。
* **逆向工程**：逆向工程师使用导入表来了解程序的工作原理，以及它如何与其他系统组件交互。
* **软件破解**：不道德的用户可能会尝试修改导入表或IAT来绕过软件的授权检查，或者替换函数以改变程序的行为。
* **DLL劫持**：攻击者可能会利用IAT的动态解析特性，通过放置恶意的同名DLL在程序的搜索路径上，来劫持程序调用的DLL，从而执行恶意代码。


IAT Hook 通过修改文件中IAT拦截和修改程序调用DLL（动态链接库）中函数的过程。



^
^
## **ELF 文件的动态连接库**
一般安卓里有多个arm和x86的so，x86的so让其能在电脑模拟器里也能正常运行。

加载：
```
`.got` 是 ELF文件格式中的一个段，称为全局偏移表（Global Offset Table）。
它位于数据段中，主要用来存放全局变量和函数的地址，以支持位置无关代码。
在动态链接的程序中，`.got` 段用于存储需要延迟绑定的函数和全局变量的地址。
这些地址在程序启动时并不立即解析，而是在程序首次访问这些符号时才进行解析和更新。
简而言之，`.got` 段为程序提供了一个查找全局变量和函数实际地址的机制。

 `.got` 是 ELF 专属的动态链接“地址缓存表”；PE 没有同名段，
对应实体是 IAT，在文件里通常放在 `.rdata`/`.idata`，
运行时由 Windows 加载器填入真正的 DLL 函数/变量地址。

`.init_array`：ELF 文件里的“构造函数表”，进程启动后、main 前由 linker 顺序执行；
跟 PE 的 INT/IAT 没有结构关系，只是“同样会被提前执行”。
```


### 1 运行顺序对照（ELF ↔ PE）

```
ELF 路线：linker 映射 so → 重定位 .got.plt → 执行 .init_array → 进入 Java/JNI/Native 入口
PE 路线：Loader 映射 DLL → 根据 INT 表拿函数名 → GetProcAddress → 填 IAT 表 → 进入 WinMain
```

***

### 2 结构 & 角色对比



| 项目   | `.init_array`     | INT 表               | IAT 表               |
| :--- | :---------------- | :------------------ | :------------------ |
| 所属格式 | ELF / Android     | PE (Windows)        | PE (Windows)        |
| 所在段  | `.init_array`（可写） | 常位于 `.rdata`        | 常位于 `.rdata`（写时复制）  |
| 元素内容 | 函数指针数组            | RVA→函数名/序号          | RVA→**最终函数地址**      |
| 何时用  | **启动后立刻执行**       | **加载前**给 Loader 看名字 | **加载后**给 CALL 取地址   |
| 是否必须 | 可以为空              | 可以为空（全绑定）           | **必须正确**，否则 CALL 踩空 |
| 修改目的 | 反调试、早patch        | 无（通常只读）             | **IAT-Hook**、API 监控 |

***

### 3 实际利用场景

* **`.init_array` 劫持**\
  把自定义函数指针插进表，**linker 会帮你先跑**，比 `JNI_OnLoad` 还早，壳/反调试常用。
* **IAT Hook（PE）**\
  把 IAT 里的 RVA 改成自己的函数地址，**所有 CALL \[IAT] 就落入你的钩子**；INT 表不动，不影响系统加载。
* **抹 INT 留 IAT**\
  PE 加载器只看 IAT 最终有没有有效地址，**INT 全清零也能跑**；可用来隐藏导入函数名。

***

### 4 结论

* `.init_array` 与 INT/IAT **没有组织上的交集**；它们分属 ELF/PE 两套格式。
* 共同点是：\
  **“都在程序真正入口前被系统顺序消费”**——linker/loader 拿来**预先完成必要的初始化或地址绑定**。
* 逆向时把 `.init_array` 当成 **ELF 的“最早代码段”**，把 IAT 当成 **PE 的‘PLT/GOT’** 即可快速类比。



^
## **动态调试时的动态连接**
so 一次性映射，但内核“用多少搬多少”，一次搬 4 KB（FFF）；看到 0xFFF 只是第一页尾巴

