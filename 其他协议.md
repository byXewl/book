# 电话
公共交换电话网络（PSTN）是一种传统的电话通信系统，用于提供传统的固定电话服务。PSTN 使用电路交换技术，这意味着在通话期间，电话之间的通信线路是专门为这两个电话保留的。每个电话通话都需要一个独立的物理电路。

在OSI（开放系统互连）模型中，PSTN属于七层模型的底层，即物理层（Physical Layer）和数据链路层（Data Link Layer）。以下是详细解释：

1. **物理层（Physical Layer）：** PSTN的物理层涉及电信设备、电话线缆、光纤等物理介质，它负责在设备之间传输原始比特流。传统电话使用模拟信号传输语音信息，而物理层负责将这些模拟信号转换为电信数字信号。
2. **数据链路层（Data Link Layer）：** 在OSI模型中，数据链路层负责点对点的数据传输，而PSTN中的电路交换技术涉及到在通话期间建立专用的物理连接。这层确保通信的可靠性和完整性，防止信息在传输过程中受损或丢失。

传统的电话通信系统采用电路交换技术，这与现代的基于IP的电话系统（VoIP）有所不同。
在VoIP系统中，语音数据被数字化并封装在数据包中，然后通过互联网传输，这更符合OSI模型中的网络层和传输层的概念。在VoIP中，通信不再需要专用的物理连接，而是通过共享的网络基础设施进行。



# 蓝牙
蓝牙技术虽然不是按照七层模型严格定义的，但它有自己的协议栈和层次结构，与OSI模型中的一些层次有相似之处。

蓝牙协议栈通常包括以下主要层次：

1. **物理层（Physical Layer）**：处理物理无线传输的细节，例如频率、调制和解调等。
2. **链路层（Link Layer）**：处理数据传输、错误纠正和流控制等，其子层包括逻辑链路控制（L2CAP）、蓝牙基本频率（BB）和蓝牙链路管理（LM）。

这种结构与OSI模型中的物理层和数据链路层有一定的相似之处，但并不完全对应。蓝牙协议栈的设计更专注于短距离无线通信的需求，包括低功耗、低复杂性和设备之间的直接连接。

Bluetooth 技术可以被看作是物理层和数据链路层之间的一种特定协议或技术。它提供了用于设备之间通信的低功耗无线连接。在 OSI 模型中，它的功能涵盖了物理层和数据链路层。它有自己的协议堆栈，包括物理层的射频通信和数据链路层的逻辑链路控制。

Bluetooth 的数据单元通常被称为 "包"（packet），用于在设备之间传输数据。这些包包含有关传输的信息，如数据、地址和控制信息。

# NFC

NFC 也不严格归类为 OSI 模型中的链路层。它是一种近距离通信技术，常用于移动支付、数据传输和标签识别。NFC 技术实质上是一种射频识别技术，允许设备在非常近的距离内进行通信。

NFC 的数据传输单位可以是数据包或帧。通常，NFC 通信的基本单位是 "消息"，这些消息包含数据以及控制信息，例如命令和响应。

Bluetooth和NFC技术不属于传统网络模型（比如 OSI 模型）中的链路层。它们更倾向于被归类为物理层和数据链路层之间的特定类型，而不是严格意义上的链路层。


# 收音机广播
收音机广播：是指广播电台通过调幅（AM）或调频（FM）方式将声音信号传输到广域范围内的收音机。这种广播方式传输的内容是音频信号，被用于传播新闻、音乐、访谈等媒体内容，接收端是广播收音机。

# MQTT
物联网(IOT)协议
长连接，比websocket轻量。
可以消息队列，发布和订阅。

# WebSocket
长连接。
WebSocket是一个TCP上的持久的全双向通信协议，它在握手阶段采用 HTTP/1.1 协议，即通过http连接，然后tcp通信。
更低的延迟，更高的实时性。
以下是 WebSocket 握手和通信的基本步骤：
1. **HTTP 握手**：
   * WebSocket 客户端发送一个 HTTP 请求到服务器，这个请求包含了特定的 `Upgrade` 头部，表明它想要将连接升级到 WebSocket 协议。例如：
     ```
     GET /chat HTTP/1.1
     Host: server.example.com
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
     Sec-WebSocket-Origin: http://example.com
     Sec-WebSocket-Version: 13
     ```
2. **服务器响应**：
   * 如果服务器同意升级连接，则会发送一个 HTTP 响应，表明连接已经成功升级到 WebSocket。例如：

     ```
     HTTP/1.1 101 Switching Protocols
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
     ```






# Socks协议 
Socks 协议是一种代理 (Proxy) 协议,，通常被用于通过基础防火墙和网络地址转换（NAT）设备进行安全的网络通信。SOCKS协议工作在 OSI 模型的传输层（第四层）。
例如我们所熟知的 Shdowsocks（机） 便是 Socks 协议的一个典型应用程序，Socks 协议目前最新的版本为5。

Socks允许客户端通过代理服务器连接到目标服务器，从而在一些情况下实现匿名浏览、绕过防火墙等功能。Socks并不提供加密，它主要关注在网络上的数据传输。

组织内部要有自己专用的网络, 该网络与公共网络是隔离的, 而代理服务器可以创建一个从内网到外网的通道, 用于组织内的主机与组织外的主机进行通信, 同时组织管理者可以在代理服务器上配置相应的权限管控和监控, 以约束和审查组织内外主机的通信行为。
Socks 5 协议工作在传输层 与应用层 的中间, 提供了一种对应用层协议透明的代理服务, 当组织内主机与代理服务器完成 Socks 握手之后, 应用层对代理服务器是无感知的, 例如地址分别为 A, B 的分布在组织内外的两个进程进行 HTTP 通信, 其中 C 为代理服务器, 实际的数据链路为 A → C → B, 但在引入 Socks 协议之后, 从应用层的视角来看, 整个通信过程仍然是 A → B 的模式。

# SSL/TLS协议
SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全性）都是用于在计算机网络上提供安全通信的协议。TLS是SSL的继任者，TLS更加安全且包含一些改进，主要用于加密Web浏览器和服务器之间的通信（例如，HTTPS协议）。
1. **SSL协议：** SSL是最早被开发用于保护互联网通信的协议。它的首个版本是SSL 1.0，但由于安全性问题，从未正式发布。SSL的公开版本从SSL 2.0开始，然后是SSL 3.0。SSL在1990年代和2000年代初广泛应用于安全通信，特别是在HTTPS中，用于加密Web浏览器和服务器之间的数据传输。
2. **TLS协议：** 由于SSL存在一些安全漏洞，TLS被设计为其更安全的替代品。TLS的第一个版本是TLS 1.0，随后有TLS 1.1、TLS 1.2和TLS 1.3。TLS 1.2目前是广泛使用的版本，而TLS 1.3是最新的版本，提供更强大的安全性和性能改进。TLS 1.3已经取代了TLS 1.2，并在许多Web浏览器和服务器中得到支持。
3. **与TCP协议的关系：** SSL和TLS都位于TCP/IP协议栈中的传输层。它们的主要功能是在应用层和传输层之间提供一个安全的通信通道。在使用SSL或TLS时，它们在传输层（通常是TCP）上提供了加密、数据完整性和身份验证等安全特性。SSL/TLS协议使用TCP作为它们的传输层协议，因为TCP提供了可靠的、面向连接的通信，这符合SSL/TLS对安全通信的要求。

4. **非对称加密：** SSL/TLS 会使用非对称加密（例如RSA或ECDH）进行握手阶段，其中服务器和客户端使用公钥和私钥进行通信。非对称加密用于以下目的：

   * **密钥交换：** 在握手阶段，服务器的公钥用于安全地交换对称密钥（Pre-Master Secret）。
   * **身份验证：** 服务器可以使用数字证书证明其身份。

5. **对称加密：** 一旦握手阶段完成，SSL/TLS 会切换到对称加密算法（例如AES）来加密实际的数据传输。对称加密效率高，因此更适合用于加密大量的实际数据。在握手阶段，通过使用非对称加密，SSL/TLS 安全地协商了共享的对称密钥，用于保护通信的隐私。



在一个典型的安全通信场景中，Web浏览器和服务器之间的通信流程通常如下：浏览器和服务器首先建立TCP连接，然后通过SSL/TLS握手来协商加密算法、密钥交换等信息，最终建立一个安全的通信通道。这样，应用层的数据就可以通过这个安全通道进行加密和解密，确保通信的机密性和完整性。

有时候在使用Socks代理时，可以通过SSL或TLS来加密数据传输，提高通信的安全性。这种情况下，Socks主要负责代理功能，而SSL/TLS负责加密和安全性。

# 国密TLS
国密TLS是使用国密算法（SM2、SM3、SM4等）替代传统的非国密算法的一种TLS协议实现。
政府、军事、金融等领域可以使用国密TLS，配置国密TLS通常涉及到在申请HTTPS证书时的配置。国密算法涵盖了非对称加密（SM2）、哈希算法（SM3）和对称加密（SM4），这使得它们在数字签名、数据完整性验证和数据加密等方面都具备了安全性。




#  java RMI
RMI算是JAVA定制版RPC吧
RMI（Remote Method Invocation，远程方法调用）并不是一个独立的协议，而是一种Java编程语言中用于实现远程过程调用的机制。它允许在Java虚拟机（JVM）上运行的对象调用其他JVM上的对象的方法，就好像调用本地对象的方法一样。
RMI并不涉及底层协议的具体实现，而是建立在Java的底层网络协议之上，通常使用Java远程对象协议（JRMP）来进行通信。JRMP是一种Java专用的二进制协议，它用于在RMI系统中传输Java对象和调用信息。
rmi://

# LDAP协议
轻量级目录访问协议，是一种用于访问和维护分布式目录信息服务的开放标准 应用层协议。LDAP最初设计用于提供对X.500目录服务的简化访问，但相比X.500，LDAP更轻量级且易于实现。


LDAP协议基于客户端-服务器模型，允许客户端向LDAP服务器发送请求并接收响应。LDAP主要用于查询和修改存储在目录中的信息，如用户信息、组织结构、网络设备等。




# 分布式系统通信协议
RESTful、RPC、gRPC和RMI都是用于实现分布式系统中远程通信的技术。

RPC是一种通用的概念，RESTful，gRPC和RMI可以看作是RPC的具体实现。


1. **RPC（Remote Procedure Call）:**
   * RPC是一种通信协议，允许一个程序调用另一个程序上的过程（函数或方法），就像调用本地过程一样，而无需了解底层的网络细节。
   * RPC提供了一种远程通信的机制，使得分布式系统中的不同部分能够相互调用。
   * 传统的RPC通常使用类似于SOAP（Simple Object Access Protocol）或RESTful HTTP的协议，但并不限于这些。

2. **gRPC:**
   * gRPC是一个高性能、开源的RPC框架，由Google开发，并基于HTTP/2协议设计，go语言适合，其他语言也可以用。一种基于 HTTP2 的tcp长连接协议，常用与服务器与服务器交互之间。
其优越的性能，它很契合微服务、游戏、loT 等需要高性能低延迟的场景。
gRPC和传统的RPC之间的主要区别在于采用了现代的协议（HTTP/2）和IDL（Protocol Buffers），提供了更高效、强大、跨语言的远程通信方式。
   * gRPC使用Protocol Buffers作为接口定义语言（IDL），提供强大的跨语言支持，允许开发者定义服务和消息，并生成多种语言的客户端和服务器代码。
   * gRPC支持双向流、多语言支持、流式处理等特性，是一个现代化的RPC框架。
   * 基于HTTP/2：使用HTTP/2的多路复用技术，允许多个RPC调用复用同一个连接，减少了连接的建立和关闭的开销。
   * **流式调用**：支持双向流式RPC，允许在方法调用过程中，客户端和服务器可以独立地发送消息。
   * **协议缓冲**：使用Protocol Buffers作为默认的数据序列化机制，提供了高效的数据编码和解码。
   * **语言中立**：提供了多种语言的库，包括Java、C++、Python、Go、Ruby等。
   * **安全性**：集成了传输层安全性（TLS），支持安全的通信。




3. **RMI（Remote Method Invocation）:**
   * RMI是Java平台的一种机制，用于实现远程对象之间的方法调用。
   * RMI允许在不同的Java虚拟机上执行Java对象的方法，使得分布式Java应用程序可以通过调用远程对象的方法来进行通信。

4. **RESTful Web Services:**
    * 虽然不是传统的RPC，但基于 REST 架构的 Web Services 也可以看作是一种远程调用方式。RESTful服务使用标准的HTTP方法（如GET、POST、PUT、DELETE）进行通信。

6. **webhook**












