Cross-site Request Forgery: 
跨站请求伪造，
用js、表单等技术，去作一些本应该用户本身才能做的操作。
攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作。
在做一些敏感操作前，仅校验了身份和权限，没有校验请求发起者本人意愿性。如：敏感操作前没有先输入验证码、表单没有唯一值的csrf_token参数。

简单来说就是伪造未授权访问。


## **场景**
**配合XSS：**
xss伪造请求，让受害者无知觉cookie被盗取，或盗用，进行操作，如自动修改密码，自动转账，自动修改绑定的邮箱，自动发送验证码，自动使用余额购买商品等。
^
**测试"水平越权，垂直越权"操作：**
用两个账号，登录两个账号，用一个账号登录的cookie去请求另一个账号的操作(如提交表单)，显示操作成功。
可以使用bp右键表单请求包，构造csrf表单，用登录另一个账号的浏览器去请求提交表单。
漏洞原因：开发者在开发进行操作的接口，传入操作的目标参数后，只简单的判断了用户是否登录(携带cookie或jwt)，用户是否在同一权限组，或者什么也没有判断，导致可以越权操作。

^
CSRF一般受同源策略的限制,没有返回值,只能提交请求,越权可以执行并获取返回值,只是返回值超出了自身账户的权限。


场景：
a 用户访问过站点A并产生了cookie,
a用户没有退出A同时访问了B站点，在B站点里存在csrf访问A地址敏感操作，
应该会先触发 CORS 吧？

会触发同源策略机制，但是不影响csrf。
——虽然A和B站点非同源，B站点脚本无法操作A站点网页数据，但是不影响它向A站点的后端发送请求，即便后端没有开启CORS，也是可以正常返回（前提是没有校验referer字段）响应数据给浏览器的，只不过浏览器会报错，拿不到响应数据。



