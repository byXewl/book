linux库：.o .so
windows库：静态库.lib，动态库.dll

linux库：静态库.a，共享动态库.so  ，可执行文件共享库.elf
* `.elf` 文件可以是可执行文件，也可以是目标文件，它是链接和编译过程中的产物。
* `.a` 静态库文件是一个归档，包含了多个目标文件，这些目标文件可以是 `.elf` 格式的。
* `.so` 共享库文件是一种特殊的 `.elf` 文件，它包含了可被多个程序共享的代码和资源。共享库在运行时被动态加载和链接。


windows库：静态库.lib，动态库.dll


1. **静态链接库**：

   * 静态链接库在编译时被链接到目标程序中，目标程序在运行时不需要外部的库文件支持。
   * 静态链接库会将库中的代码完全复制到目标程序中，因此目标程序会变得比较大。
   * 如果多个程序使用同一个静态链接库，每个程序都会包含一份该库的完整拷贝。
   * 在程序发布时，需要将所有依赖的静态链接库一同发布。

2. **动态链接库**：

   * 动态链接库在编译时并不会被链接到目标程序中，而是在运行时由操作系统动态加载。
   * 多个程序可以共享同一个动态链接库的实例，节省内存空间。
   * 动态链接库的更新或修复可以在不重新编译程序的情况下进行。
   * 如果某个库被多个程序使用，动态链接库只需要被存储一次，减少了磁盘空间的浪费。


## **静态库创建使用**
使用编译器（如 `gcc` 或 `g++`）将源文件编译为目标文件（`.o` 文件）。示例命令：
   ```
   gcc -c -o file1.o file1.c
   gcc -c -o file2.o file2.c
   ```
使用 ar命令将所有的目标文件打包成一个静态库文件（`.a` 文件）。示例命令：
   ```
   ar rcs libmylib.a file1.o file2.o
   ```
   其中，`libmylib.a` 是静态库文件的名称。

## **动态库创建使用**
**编译为位置无关代码**：使用 `-fPIC` 选项编译源文件，生成位置无关代码（PIC，Position Independent Code）
   ```
   gcc -c -fPIC -o file1.o file1.c
   gcc -c -fPIC -o file2.o file2.c
   ```

**链接为共享对象**：使用编译器将位置无关代码链接为共享对象文件（`.so` 文件）。示例命令：
   ```
   gcc -shared -o libmylib.so file1.o file2.o
   ```
   其中，`libmylib.so` 是动态库文件的名称。

