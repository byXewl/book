## **负数以补码显示**

补码：**-4，则把正数4按位取反再加 1** 就得到补码。
位数固定后，负数自然对应到高字节全是 `F` 的那些值。

下面按 8-bit、16-bit、32-bit 分别算给你看，一眼就能记住规律。

#### 一、8 位（BYTE）

1. 先写 +4
   `0000 0100` = 0x04
2. 按位取反
   `1111 1011` = 0xFB
3. 再加 1
   `1111 1100` = 0xFC ← 这就是 -4
4. 同理 +1
   `0000 0001`
   取反 `1111 1110`
   +1 `1111 1111` = 0xFF ← 这就是 -1


####  二、16 位（WORD）
-4
+4 = 0x0004\
取反 0xFFFB\
+1 0xFFFC ← 16 位 -4

\-1\
+1 = 0x0001\
取反 0xFFFE\
+1 0xFFFF ← 16 位 -1

***

#### 三、32 位（DWORD）

\-4\
+4 = 0x00000004\
取反 0xFFFFFFFB\
+1 0xFFFFFFFC ← 32 位 -4

\-1\
+1 = 0x00000001\
取反 0xFFFFFFFE\
+1 0xFFFFFFFF ← 32 位 -1

***

#### 四、快速口算口诀

“负数补码 = 0 - 这个数”
因为寄存器位数固定，0 减正数自然向高位借位，结果就是上面那一串 `F` 结尾的值。

例（8 位）：
0x00 - 0x04 = 0xFC
0x00 - 0x01 = 0xFF

记住 8 位结果，别的位宽只是前面再补 `F` 而已：

| 数值 | 8 位 | 16 位 | 32 位     |
| :- | :-- | :--- | :------- |
| -1 | FF  | FFFF | FFFFFFFF |
| -4 | FC  | FFFC | FFFFFFFC |



^
## **大端小端存储显示**
对于-4
* **x86、x64、ARM 默认小端** → 你调试器里看到 `FC FF FF FF`。
* **老式 PowerPC、SPARC、MIPS 大端模式** → 内存里就是 `FF FF FF FC`。
* **ARM、RISC-V、MIPS 可配置端序** → 取决于启动时设定的 **EBE/ELB** 位。

* **你眼睛看到伪代码值注释 0xFFFFFFFC** 只是调试器把字节逆序后凑成的“整数值”，方便人类阅读。

```
人类阅读格式（大端，高位在前）
为了好看，调试器/计算器把同一串字节反着印出来：
`0xFFFFFFFC` ← 这是给人看的“数值”

内存/文件顺序（小端，低位在前）
落到文件或内存里，地址从低到高就是：
地址 : 值
1000 : FC
1001 : FF
1002 : FF
1003 : FF
```


^
## **负数场景**
strcmp()函数可能返回-1或负数。其按无符号字符 逐字节比较，直到出现不相等的字符或遇到 '\0'。

1、glibc / MSVC中
只保证符号，不保证绝对值：
小 < 大 → 返回 (s1[i] - s2[i]) 的差值（负）
大 > 小 → 返回同一差值（正）
因此可能看到 -6、0、+7 而不仅仅是 -1 、0、 +1。

2、精简库（musl、newlib、kernel 版）中
为了节省指令，常直接返回 -1 / 0 / 1。



^


## **浮点数显示**



“小数”是你按 **IEEE-754** 或 **定点格式**去**解释**同一段位模式时才出现的；调试器额外给你开了**浮点窗口**，才把那些位“翻译”成人类可读的小数。


